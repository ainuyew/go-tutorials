package main

// Code generated by github.com/parsyl/parquet.  DO NOT EDIT.

import (
	"encoding/binary"
	"fmt"
	"io"
	"math"
	"strings"

	"github.com/parsyl/parquet"
	sch "github.com/parsyl/parquet/schema"
	"github.com/valyala/bytebufferpool"
)

var _ = math.MaxInt32 // to avoid unused import

type compression int

const (
	compressionUncompressed compression = 0
	compressionSnappy       compression = 1
	compressionGzip         compression = 2
	compressionUnknown      compression = -1
)

var buffpool = bytebufferpool.Pool{}

// ParquetWriter reprents a row group
type ParquetWriter struct {
	fields []Field

	len int

	// child points to the next page
	child *ParquetWriter

	// max is the number of Record items that can get written before
	// a new set of column chunks is written
	max int

	meta        *parquet.Metadata
	w           io.Writer
	compression compression
}

func Fields(compression compression) []Field {
	return []Field{
		NewFloat64OptionalField(readValuationdetail, writeValuationdetail, []string{"valuationdetail"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readValuation, writeValuation, []string{"valuation"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readPosition, writePosition, []string{"position"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readPosdetail, writePosdetail, []string{"posdetail"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readValuetime, writeValuetime, []string{"valuetime"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readBegtime, writeBegtime, []string{"begtime"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readEndtime, writeEndtime, []string{"endtime"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readQuantitystatus, writeQuantitystatus, []string{"quantitystatus"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readDescription, writeDescription, []string{"description"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readQuantity, writeQuantity, []string{"quantity"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readPricequantity, writePricequantity, []string{"pricequantity"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readExposurequantity, writeExposurequantity, []string{"exposurequantity"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readPrice, writePrice, []string{"price"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readValue, writeValue, []string{"value"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readMarketprice, writeMarketprice, []string{"marketprice"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readMarketvalue, writeMarketvalue, []string{"marketvalue"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readUnit, writeUnit, []string{"unit"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readQuantitytype, writeQuantitytype, []string{"quantitytype"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readPositionstatus, writePositionstatus, []string{"positionstatus"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readEvergreenstatus, writeEvergreenstatus, []string{"evergreenstatus"}, []int{1}, optionalFieldCompression(compression)),
		NewBoolOptionalField(readSettlementstatus, writeSettlementstatus, []string{"settlementstatus"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readExpectedduedate, writeExpectedduedate, []string{"expectedduedate"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExposure, writeExposure, []string{"exposure"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readPricestatus, writePricestatus, []string{"pricestatus"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExposuretype, writeExposuretype, []string{"exposuretype"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readPriceindex, writePriceindex, []string{"priceindex"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readCurrency, writeCurrency, []string{"currency"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readPriceunit, writePriceunit, []string{"priceunit"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTrade, writeTrade, []string{"trade"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readNpvfactor, writeNpvfactor, []string{"npvfactor"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readValidation, writeValidation, []string{"validation"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readPricedate, writePricedate, []string{"pricedate"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readStrikeprice, writeStrikeprice, []string{"strikeprice"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readOptrefprice, writeOptrefprice, []string{"optrefprice"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readIntrate, writeIntrate, []string{"intrate"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readOptionvalue, writeOptionvalue, []string{"optionvalue"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readDelta, writeDelta, []string{"delta"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readGamma, writeGamma, []string{"gamma"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readTheta, writeTheta, []string{"theta"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readVega, writeVega, []string{"vega"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readRho, writeRho, []string{"rho"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTimezone, writeTimezone, []string{"timezone"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readVolatility, writeVolatility, []string{"volatility"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readPromptvolatility, writePromptvolatility, []string{"promptvolatility"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readVar, writeVar, []string{"var"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readProduct, writeProduct, []string{"product"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readFee, writeFee, []string{"fee"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readFeetype, writeFeetype, []string{"feetype"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readShipment, writeShipment, []string{"shipment"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readMeasure, writeMeasure, []string{"measure"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTsperiod, writeTsperiod, []string{"tsperiod"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readFuturemonth, writeFuturemonth, []string{"futuremonth"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExpirationdate, writeExpirationdate, []string{"expirationdate"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readSettlementdate, writeSettlementdate, []string{"settlementdate"}, []int{1}, optionalFieldCompression(compression)),
		NewBoolOptionalField(readDaylightsaving, writeDaylightsaving, []string{"daylightsaving"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readMarketdayhour, writeMarketdayhour, []string{"marketdayhour"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readCycle, writeCycle, []string{"cycle"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTaxlocation, writeTaxlocation, []string{"taxlocation"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readOptionstatus, writeOptionstatus, []string{"optionstatus"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readContract, writeContract, []string{"contract"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readCompositeindex, writeCompositeindex, []string{"compositeindex"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readCompany, writeCompany, []string{"company"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readCounterparty, writeCounterparty, []string{"counterparty"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTrader, writeTrader, []string{"trader"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTradebook, writeTradebook, []string{"tradebook"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readCurrencyfactor, writeCurrencyfactor, []string{"currencyfactor"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readPaymentterms, writePaymentterms, []string{"paymentterms"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTransactiontype, writeTransactiontype, []string{"transactiontype"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readComponent, writeComponent, []string{"component"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readBlock, writeBlock, []string{"block"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readMarketarea, writeMarketarea, []string{"marketarea"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readCarrier, writeCarrier, []string{"carrier"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readLocation, writeLocation, []string{"location"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readProperty, writeProperty, []string{"property"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readPile, writePile, []string{"pile"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readQuality, writeQuality, []string{"quality"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTradetype, writeTradetype, []string{"tradetype"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readTier, writeTier, []string{"tier"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readStrategy, writeStrategy, []string{"strategy"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readStrategydetail, writeStrategydetail, []string{"strategydetail"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readHedge, writeHedge, []string{"hedge"}, []int{1}, optionalFieldCompression(compression)),
		NewBoolOptionalField(readHypothetical, writeHypothetical, []string{"hypothetical"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readProducttype, writeProducttype, []string{"producttype"}, []int{1}, optionalFieldCompression(compression)),
		NewBoolOptionalField(readMovement, writeMovement, []string{"movement"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readPricebegtime, writePricebegtime, []string{"pricebegtime"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readPriceendtime, writePriceendtime, []string{"priceendtime"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readSettlementcurrexchrate, writeSettlementcurrexchrate, []string{"settlementcurrexchrate"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readSettlementcurrency, writeSettlementcurrency, []string{"settlementcurrency"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readCashnpvfactor, writeCashnpvfactor, []string{"cashnpvfactor"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readFintransact, writeFintransact, []string{"fintransact"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readFxstatus, writeFxstatus, []string{"fxstatus"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readFxcurrency, writeFxcurrency, []string{"fxcurrency"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readFxexposure, writeFxexposure, []string{"fxexposure"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readFxvalue, writeFxvalue, []string{"fxvalue"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readFxrisk, writeFxrisk, []string{"fxrisk"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readFxvolatility, writeFxvolatility, []string{"fxvolatility"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readFxbegtime, writeFxbegtime, []string{"fxbegtime"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readFxendtime, writeFxendtime, []string{"fxendtime"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readQuantityattribution, writeQuantityattribution, []string{"quantityattribution"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readDeltaattribution, writeDeltaattribution, []string{"deltaattribution"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readValueattribution, writeValueattribution, []string{"valueattribution"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readGammaattribution, writeGammaattribution, []string{"gammaattribution"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readMarketvalueattribution, writeMarketvalueattribution, []string{"marketvalueattribution"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTransactionattribution, writeTransactionattribution, []string{"transactionattribution"}, []int{1}, optionalFieldCompression(compression)),
		NewBoolOptionalField(readNewposition, writeNewposition, []string{"newposition"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readNonlinearattribution, writeNonlinearattribution, []string{"nonlinearattribution"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTpseason, writeTpseason, []string{"tpseason"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTpyear, writeTpyear, []string{"tpyear"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTpquarter, writeTpquarter, []string{"tpquarter"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTpmonth, writeTpmonth, []string{"tpmonth"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTpweek, writeTpweek, []string{"tpweek"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTpday, writeTpday, []string{"tpday"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readGreekfactor, writeGreekfactor, []string{"greekfactor"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readExposuremonth, writeExposuremonth, []string{"exposuremonth"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExposureindex, writeExposureindex, []string{"exposureindex"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readAccountname, writeAccountname, []string{"accountname"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readCreationdate, writeCreationdate, []string{"creationdate"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readRevisionname, writeRevisionname, []string{"revisionname"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readCreationname, writeCreationname, []string{"creationname"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readRevisiondate, writeRevisiondate, []string{"revisiondate"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readAmendedattribution, writeAmendedattribution, []string{"amendedattribution"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readCurrexchrate, writeCurrexchrate, []string{"currexchrate"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readCurrexchratecash, writeCurrexchratecash, []string{"currexchratecash"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readDiscountedmarketvalue, writeDiscountedmarketvalue, []string{"discountedmarketvalue"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readDiscountedvalue, writeDiscountedvalue, []string{"discountedvalue"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readFeeattribution, writeFeeattribution, []string{"feeattribution"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readFxattribution, writeFxattribution, []string{"fxattribution"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readIntransitstatus, writeIntransitstatus, []string{"intransitstatus"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readIrattribution, writeIrattribution, []string{"irattribution"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readLosstype, writeLosstype, []string{"losstype"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readNetrate, writeNetrate, []string{"netrate"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readRateunit, writeRateunit, []string{"rateunit"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readThetaattribution, writeThetaattribution, []string{"thetaattribution"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readVegaattribution, writeVegaattribution, []string{"vegaattribution"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readArchive, writeArchive, []string{"archive"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readDeltaexposure, writeDeltaexposure, []string{"deltaexposure"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readDeltanpvfactor, writeDeltanpvfactor, []string{"deltanpvfactor"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTimeunit, writeTimeunit, []string{"timeunit"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readDuration, writeDuration, []string{"duration"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExpcurrency, writeExpcurrency, []string{"expcurrency"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readExpprice, writeExpprice, []string{"expprice"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExppriceunit, writeExppriceunit, []string{"exppriceunit"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readPriceexpquantity, writePriceexpquantity, []string{"priceexpquantity"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readRecordtype, writeRecordtype, []string{"recordtype"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readPositiontype, writePositiontype, []string{"positiontype"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_destinationtradebook, writeJeragm_destinationtradebook, []string{"jeragm_destinationtradebook"}, []int{1}, optionalFieldCompression(compression)),
		NewBoolOptionalField(readJeragm_internalposition, writeJeragm_internalposition, []string{"jeragm_internalposition"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readVessel, writeVessel, []string{"vessel"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_cargospecification, writeJeragm_cargospecification, []string{"jeragm_cargospecification"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_cargostatus, writeJeragm_cargostatus, []string{"jeragm_cargostatus"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_flexcategory, writeJeragm_flexcategory, []string{"jeragm_flexcategory"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_jeraltcname, writeJeragm_jeraltcname, []string{"jeragm_jeraltcname"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTradestrategy, writeTradestrategy, []string{"tradestrategy"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_buysell, writeJeragm_buysell, []string{"jeragm_buysell"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_cash, writeJeragm_cash, []string{"jeragm_cash"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_cashexp, writeJeragm_cashexp, []string{"jeragm_cashexp"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_cashvalue, writeJeragm_cashvalue, []string{"jeragm_cashvalue"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_disccash, writeJeragm_disccash, []string{"jeragm_disccash"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_discountedcashvalue, writeJeragm_discountedcashvalue, []string{"jeragm_discountedcashvalue"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_exposure, writeJeragm_exposure, []string{"jeragm_exposure"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_fxstate, writeJeragm_fxstate, []string{"jeragm_fxstate"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_pricemarketprice, writeJeragm_pricemarketprice, []string{"jeragm_pricemarketprice"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_pricestate, writeJeragm_pricestate, []string{"jeragm_pricestate"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_product, writeJeragm_product, []string{"jeragm_product"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_qtyunit, writeJeragm_qtyunit, []string{"jeragm_qtyunit"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_quant, writeJeragm_quant, []string{"jeragm_quant"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_rate, writeJeragm_rate, []string{"jeragm_rate"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readRate, writeRate, []string{"rate"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readSwaptype, writeSwaptype, []string{"swaptype"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExpproduct, writeExpproduct, []string{"expproduct"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExpproducttype, writeExpproducttype, []string{"expproducttype"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExpreportingqty, writeExpreportingqty, []string{"expreportingqty"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExpreportingunit, writeExpreportingunit, []string{"expreportingunit"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readMarketareapi, writeMarketareapi, []string{"marketareapi"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_freightshipment, writeJeragm_freightshipment, []string{"jeragm_freightshipment"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExchange, writeExchange, []string{"exchange"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_postingtype, writeJeragm_postingtype, []string{"jeragm_postingtype"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readPositionmode, writePositionmode, []string{"positionmode"}, []int{1}, optionalFieldCompression(compression)),
		NewBoolOptionalField(readJeragm_fullypriced, writeJeragm_fullypriced, []string{"jeragm_fullypriced"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_marktoIntentprice, writeJeragm_marktoIntentprice, []string{"Jeragm_marktoIntentprice"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_marktointentvalue, writeJeragm_marktointentvalue, []string{"Jeragm_marktointentvalue"}, []int{1}, optionalFieldCompression(compression)),
		NewBoolOptionalField(readJeragm_intransitinventory, writeJeragm_intransitinventory, []string{"Jeragm_intransitinventory"}, []int{1}, optionalFieldCompression(compression)),
		NewBoolOptionalField(readJeragm_PosEndDateInFuture, writeJeragm_PosEndDateInFuture, []string{"Jeragm_PosEndDateInFuture"}, []int{1}, optionalFieldCompression(compression)),
		NewBoolOptionalField(readJeragm_settlementstatus, writeJeragm_settlementstatus, []string{"Jeragm_settlementstatus"}, []int{1}, optionalFieldCompression(compression)),
		NewBoolOptionalField(readJeragm_fullypricedpos, writeJeragm_fullypricedpos, []string{"jeragm_fullypricedpos"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readJeragm_duedate, writeJeragm_duedate, []string{"jeragm_duedate"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readContainer, writeContainer, []string{"container"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readContainertype, writeContainertype, []string{"containertype"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExchangematchid, writeExchangematchid, []string{"exchangematchid"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readLossquantity, writeLossquantity, []string{"lossquantity"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readUnitseq, writeUnitseq, []string{"unitseq"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExpreportingqty2, writeExpreportingqty2, []string{"expreportingqty2"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExpreportingqty3, writeExpreportingqty3, []string{"expreportingqty3"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExpreportingunit2, writeExpreportingunit2, []string{"expreportingunit2"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readExpreportingunit3, writeExpreportingunit3, []string{"expreportingunit3"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readTl_sourcetrade, writeTl_sourcetrade, []string{"tl_sourcetrade"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_brand, writeJeragm_brand, []string{"jeragm_brand"}, []int{1}, optionalFieldCompression(compression)),
		NewBoolOptionalField(readJeragm_includeincvbaseprice, writeJeragm_includeincvbaseprice, []string{"jeragm_includeincvbaseprice"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_referencecv, writeJeragm_referencecv, []string{"jeragm_referencecv"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readIncoterms, writeIncoterms, []string{"incoterms"}, []int{1}, optionalFieldCompression(compression)),
		NewBoolOptionalField(readJeragm_final, writeJeragm_final, []string{"jeragm_final"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_bestavailablecv, writeJeragm_bestavailablecv, []string{"jeragm_bestavailablecv"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_marktointentaccrualvalue, writeJeragm_marktointentaccrualvalue, []string{"jeragm_marktointentaccrualvalue"}, []int{1}, optionalFieldCompression(compression)),
		NewBoolOptionalField(readJeragm_fxconversion, writeJeragm_fxconversion, []string{"jeragm_fxconversion"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readJeragm_fxcurrencybegtime, writeJeragm_fxcurrencybegtime, []string{"jeragm_fxcurrencybegtime"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readJeragm_fxcurrencyendtime, writeJeragm_fxcurrencyendtime, []string{"jeragm_fxcurrencyendtime"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readJeragm_bldate, writeJeragm_bldate, []string{"jeragm_bldate"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_matchno, writeJeragm_matchno, []string{"jeragm_matchno"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readBunkertype, writeBunkertype, []string{"bunkertype"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readGammacurve, writeGammacurve, []string{"gammacurve"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readHedgecurve, writeHedgecurve, []string{"hedgecurve"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readVegacurve, writeVegacurve, []string{"vegacurve"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_fxrate, writeJeragm_fxrate, []string{"jeragm_fxrate"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_originaldelta, writeJeragm_originaldelta, []string{"jeragm_originaldelta"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_yearquarter, writeJeragm_yearquarter, []string{"jeragm_yearquarter"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readJeragm_deliverymonth, writeJeragm_deliverymonth, []string{"jeragm_deliverymonth"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readJeragm_deliveryquarter, writeJeragm_deliveryquarter, []string{"jeragm_deliveryquarter"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readJeragm_deliveryyear, writeJeragm_deliveryyear, []string{"jeragm_deliveryyear"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_deltaposition, writeJeragm_deltaposition, []string{"jeragm_deltaposition"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_discexp, writeJeragm_discexp, []string{"jeragm_discexp"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_discexp2, writeJeragm_discexp2, []string{"jeragm_discexp2"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_discexp3, writeJeragm_discexp3, []string{"jeragm_discexp3"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_expmonth, writeJeragm_expmonth, []string{"jeragm_expmonth"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_expmonth_coal, writeJeragm_expmonth_coal, []string{"jeragm_expmonth_coal"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_expseasons, writeJeragm_expseasons, []string{"jeragm_expseasons"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_expyears, writeJeragm_expyears, []string{"jeragm_expyears"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_expquarters, writeJeragm_expquarters, []string{"jeragm_expquarters"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_quality_, writeJeragm_quality_, []string{"jeragm_quality_"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_reppostype, writeJeragm_reppostype, []string{"jeragm_reppostype"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_exposurestatus, writeJeragm_exposurestatus, []string{"jeragm_exposurestatus"}, []int{1}, optionalFieldCompression(compression)),
		NewInt64OptionalField(readJeragm_exprolloffdate, writeJeragm_exprolloffdate, []string{"jeragm_exprolloffdate"}, []int{1}, optionalFieldCompression(compression)),
		NewFloat64OptionalField(readJeragm_signedpriceqty, writeJeragm_signedpriceqty, []string{"jeragm_signedpriceqty"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readRangepricingtype, writeRangepricingtype, []string{"rangepricingtype"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_customdisaggkey, writeJeragm_customdisaggkey, []string{"jeragm_customdisaggkey"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_customdisagglabel, writeJeragm_customdisagglabel, []string{"jeragm_customdisagglabel"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_concatenation, writeJeragm_concatenation, []string{"jeragm_concatenation"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_customposref, writeJeragm_customposref, []string{"jeragm_customposref"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_customtraderef, writeJeragm_customtraderef, []string{"jeragm_customtraderef"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_getraderef, writeJeragm_getraderef, []string{"jeragm_getraderef"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_priceindex, writeJeragm_priceindex, []string{"jeragm_priceindex"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readIntrinsicprice, writeIntrinsicprice, []string{"intrinsicprice"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_mmvolannual, writeJeragm_mmvolannual, []string{"jeragm_mmvolannual"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_mmvoltomaturity, writeJeragm_mmvoltomaturity, []string{"jeragm_mmvoltomaturity"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_nfixings, writeJeragm_nfixings, []string{"jeragm_nfixings"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_settlementprice, writeJeragm_settlementprice, []string{"jeragm_settlementprice"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_settlementtype, writeJeragm_settlementtype, []string{"jeragm_settlementtype"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_cashnpvfactororiginal, writeJeragm_cashnpvfactororiginal, []string{"jeragm_cashnpvfactororiginal"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_cashnpvfactorusd, writeJeragm_cashnpvfactorusd, []string{"jeragm_cashnpvfactorusd"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_currexchratecashusd, writeJeragm_currexchratecashusd, []string{"jeragm_currexchratecashusd"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_currexchratespot, writeJeragm_currexchratespot, []string{"jeragm_currexchratespot"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_currexchratespotusd, writeJeragm_currexchratespotusd, []string{"jeragm_currexchratespotusd"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_timetoexpiry, writeJeragm_timetoexpiry, []string{"jeragm_timetoexpiry"}, []int{1}, optionalFieldCompression(compression)),
		NewStringOptionalField(readJeragm_fxdiscountdate, writeJeragm_fxdiscountdate, []string{"jeragm_fxdiscountdate"}, []int{1}, optionalFieldCompression(compression)),
	}
}

func readValuationdetail(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Valuationdetail == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Valuationdetail)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeValuationdetail(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Valuationdetail = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readValuation(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Valuation == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Valuation)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeValuation(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Valuation = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPosition(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Position == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Position)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePosition(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Position = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPosdetail(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Posdetail == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Posdetail)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePosdetail(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Posdetail = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readValuetime(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Valuetime == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Valuetime)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeValuetime(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Valuetime = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readBegtime(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Begtime == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Begtime)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeBegtime(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Begtime = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readEndtime(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Endtime == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Endtime)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeEndtime(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Endtime = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readQuantitystatus(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Quantitystatus == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Quantitystatus)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeQuantitystatus(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Quantitystatus = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readDescription(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Description == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Description)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeDescription(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Description = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readQuantity(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Quantity == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Quantity)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeQuantity(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Quantity = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPricequantity(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Pricequantity == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Pricequantity)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePricequantity(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Pricequantity = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExposurequantity(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Exposurequantity == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Exposurequantity)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExposurequantity(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Exposurequantity = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPrice(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Price == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Price)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePrice(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Price = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readValue(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Value == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Value)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeValue(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Value = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readMarketprice(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Marketprice == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Marketprice)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeMarketprice(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Marketprice = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readMarketvalue(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Marketvalue == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Marketvalue)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeMarketvalue(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Marketvalue = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readUnit(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Unit == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Unit)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeUnit(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Unit = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readQuantitytype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Quantitytype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Quantitytype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeQuantitytype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Quantitytype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPositionstatus(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Positionstatus == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Positionstatus)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePositionstatus(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Positionstatus = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readEvergreenstatus(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Evergreenstatus == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Evergreenstatus)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeEvergreenstatus(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Evergreenstatus = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readSettlementstatus(x ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8) {
	switch {
	case x.Settlementstatus == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Settlementstatus)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeSettlementstatus(x *ValuationDetail, vals []bool, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Settlementstatus = pbool(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExpectedduedate(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Expectedduedate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Expectedduedate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExpectedduedate(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Expectedduedate = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExposure(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Exposure == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Exposure)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExposure(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Exposure = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPricestatus(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Pricestatus == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Pricestatus)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePricestatus(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Pricestatus = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExposuretype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Exposuretype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Exposuretype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExposuretype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Exposuretype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPriceindex(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Priceindex == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Priceindex)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePriceindex(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Priceindex = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readCurrency(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Currency == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Currency)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeCurrency(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Currency = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPriceunit(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Priceunit == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Priceunit)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePriceunit(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Priceunit = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTrade(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Trade == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Trade)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTrade(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Trade = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readNpvfactor(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Npvfactor == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Npvfactor)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeNpvfactor(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Npvfactor = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readValidation(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Validation == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Validation)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeValidation(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Validation = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPricedate(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Pricedate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Pricedate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePricedate(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Pricedate = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readStrikeprice(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Strikeprice == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Strikeprice)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeStrikeprice(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Strikeprice = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readOptrefprice(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Optrefprice == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Optrefprice)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeOptrefprice(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Optrefprice = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readIntrate(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Intrate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Intrate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeIntrate(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Intrate = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readOptionvalue(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Optionvalue == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Optionvalue)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeOptionvalue(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Optionvalue = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readDelta(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Delta == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Delta)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeDelta(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Delta = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readGamma(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Gamma == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Gamma)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeGamma(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Gamma = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTheta(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Theta == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Theta)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTheta(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Theta = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readVega(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Vega == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Vega)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeVega(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Vega = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readRho(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Rho == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Rho)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeRho(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Rho = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTimezone(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Timezone == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Timezone)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTimezone(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Timezone = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readVolatility(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Volatility == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Volatility)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeVolatility(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Volatility = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPromptvolatility(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Promptvolatility == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Promptvolatility)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePromptvolatility(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Promptvolatility = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readVar(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Var == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Var)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeVar(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Var = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readProduct(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Product == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Product)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeProduct(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Product = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readFee(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Fee == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Fee)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeFee(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Fee = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readFeetype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Feetype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Feetype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeFeetype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Feetype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readShipment(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Shipment == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Shipment)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeShipment(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Shipment = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readMeasure(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Measure == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Measure)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeMeasure(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Measure = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTsperiod(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Tsperiod == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Tsperiod)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTsperiod(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Tsperiod = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readFuturemonth(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Futuremonth == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Futuremonth)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeFuturemonth(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Futuremonth = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExpirationdate(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Expirationdate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Expirationdate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExpirationdate(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Expirationdate = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readSettlementdate(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Settlementdate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Settlementdate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeSettlementdate(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Settlementdate = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readDaylightsaving(x ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8) {
	switch {
	case x.Daylightsaving == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Daylightsaving)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeDaylightsaving(x *ValuationDetail, vals []bool, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Daylightsaving = pbool(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readMarketdayhour(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Marketdayhour == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Marketdayhour)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeMarketdayhour(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Marketdayhour = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readCycle(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Cycle == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Cycle)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeCycle(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Cycle = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTaxlocation(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Taxlocation == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Taxlocation)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTaxlocation(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Taxlocation = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readOptionstatus(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Optionstatus == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Optionstatus)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeOptionstatus(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Optionstatus = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readContract(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Contract == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Contract)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeContract(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Contract = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readCompositeindex(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Compositeindex == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Compositeindex)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeCompositeindex(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Compositeindex = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readCompany(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Company == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Company)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeCompany(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Company = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readCounterparty(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Counterparty == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Counterparty)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeCounterparty(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Counterparty = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTrader(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Trader == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Trader)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTrader(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Trader = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTradebook(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Tradebook == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Tradebook)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTradebook(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Tradebook = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readCurrencyfactor(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Currencyfactor == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Currencyfactor)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeCurrencyfactor(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Currencyfactor = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPaymentterms(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Paymentterms == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Paymentterms)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePaymentterms(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Paymentterms = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTransactiontype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Transactiontype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Transactiontype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTransactiontype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Transactiontype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readComponent(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Component == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Component)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeComponent(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Component = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readBlock(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Block == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Block)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeBlock(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Block = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readMarketarea(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Marketarea == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Marketarea)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeMarketarea(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Marketarea = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readCarrier(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Carrier == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Carrier)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeCarrier(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Carrier = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readLocation(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Location == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Location)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeLocation(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Location = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readProperty(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Property == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Property)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeProperty(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Property = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPile(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Pile == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Pile)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePile(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Pile = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readQuality(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Quality == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Quality)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeQuality(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Quality = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTradetype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Tradetype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Tradetype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTradetype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Tradetype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTier(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Tier == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Tier)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTier(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Tier = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readStrategy(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Strategy == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Strategy)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeStrategy(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Strategy = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readStrategydetail(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Strategydetail == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Strategydetail)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeStrategydetail(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Strategydetail = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readHedge(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Hedge == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Hedge)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeHedge(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Hedge = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readHypothetical(x ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8) {
	switch {
	case x.Hypothetical == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Hypothetical)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeHypothetical(x *ValuationDetail, vals []bool, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Hypothetical = pbool(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readProducttype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Producttype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Producttype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeProducttype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Producttype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readMovement(x ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8) {
	switch {
	case x.Movement == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Movement)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeMovement(x *ValuationDetail, vals []bool, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Movement = pbool(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPricebegtime(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Pricebegtime == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Pricebegtime)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePricebegtime(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Pricebegtime = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPriceendtime(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Priceendtime == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Priceendtime)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePriceendtime(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Priceendtime = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readSettlementcurrexchrate(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Settlementcurrexchrate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Settlementcurrexchrate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeSettlementcurrexchrate(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Settlementcurrexchrate = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readSettlementcurrency(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Settlementcurrency == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Settlementcurrency)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeSettlementcurrency(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Settlementcurrency = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readCashnpvfactor(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Cashnpvfactor == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Cashnpvfactor)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeCashnpvfactor(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Cashnpvfactor = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readFintransact(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Fintransact == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Fintransact)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeFintransact(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Fintransact = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readFxstatus(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Fxstatus == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Fxstatus)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeFxstatus(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Fxstatus = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readFxcurrency(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Fxcurrency == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Fxcurrency)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeFxcurrency(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Fxcurrency = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readFxexposure(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Fxexposure == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Fxexposure)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeFxexposure(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Fxexposure = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readFxvalue(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Fxvalue == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Fxvalue)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeFxvalue(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Fxvalue = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readFxrisk(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Fxrisk == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Fxrisk)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeFxrisk(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Fxrisk = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readFxvolatility(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Fxvolatility == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Fxvolatility)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeFxvolatility(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Fxvolatility = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readFxbegtime(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Fxbegtime == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Fxbegtime)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeFxbegtime(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Fxbegtime = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readFxendtime(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Fxendtime == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Fxendtime)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeFxendtime(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Fxendtime = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readQuantityattribution(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Quantityattribution == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Quantityattribution)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeQuantityattribution(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Quantityattribution = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readDeltaattribution(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Deltaattribution == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Deltaattribution)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeDeltaattribution(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Deltaattribution = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readValueattribution(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Valueattribution == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Valueattribution)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeValueattribution(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Valueattribution = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readGammaattribution(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Gammaattribution == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Gammaattribution)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeGammaattribution(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Gammaattribution = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readMarketvalueattribution(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Marketvalueattribution == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Marketvalueattribution)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeMarketvalueattribution(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Marketvalueattribution = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTransactionattribution(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Transactionattribution == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Transactionattribution)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTransactionattribution(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Transactionattribution = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readNewposition(x ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8) {
	switch {
	case x.Newposition == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Newposition)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeNewposition(x *ValuationDetail, vals []bool, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Newposition = pbool(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readNonlinearattribution(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Nonlinearattribution == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Nonlinearattribution)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeNonlinearattribution(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Nonlinearattribution = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTpseason(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Tpseason == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Tpseason)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTpseason(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Tpseason = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTpyear(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Tpyear == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Tpyear)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTpyear(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Tpyear = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTpquarter(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Tpquarter == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Tpquarter)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTpquarter(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Tpquarter = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTpmonth(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Tpmonth == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Tpmonth)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTpmonth(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Tpmonth = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTpweek(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Tpweek == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Tpweek)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTpweek(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Tpweek = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTpday(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Tpday == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Tpday)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTpday(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Tpday = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readGreekfactor(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Greekfactor == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Greekfactor)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeGreekfactor(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Greekfactor = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExposuremonth(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Exposuremonth == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Exposuremonth)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExposuremonth(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Exposuremonth = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExposureindex(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Exposureindex == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Exposureindex)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExposureindex(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Exposureindex = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readAccountname(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Accountname == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Accountname)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeAccountname(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Accountname = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readCreationdate(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Creationdate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Creationdate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeCreationdate(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Creationdate = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readRevisionname(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Revisionname == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Revisionname)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeRevisionname(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Revisionname = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readCreationname(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Creationname == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Creationname)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeCreationname(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Creationname = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readRevisiondate(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Revisiondate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Revisiondate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeRevisiondate(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Revisiondate = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readAmendedattribution(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Amendedattribution == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Amendedattribution)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeAmendedattribution(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Amendedattribution = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readCurrexchrate(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Currexchrate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Currexchrate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeCurrexchrate(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Currexchrate = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readCurrexchratecash(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Currexchratecash == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Currexchratecash)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeCurrexchratecash(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Currexchratecash = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readDiscountedmarketvalue(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Discountedmarketvalue == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Discountedmarketvalue)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeDiscountedmarketvalue(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Discountedmarketvalue = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readDiscountedvalue(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Discountedvalue == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Discountedvalue)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeDiscountedvalue(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Discountedvalue = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readFeeattribution(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Feeattribution == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Feeattribution)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeFeeattribution(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Feeattribution = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readFxattribution(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Fxattribution == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Fxattribution)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeFxattribution(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Fxattribution = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readIntransitstatus(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Intransitstatus == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Intransitstatus)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeIntransitstatus(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Intransitstatus = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readIrattribution(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Irattribution == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Irattribution)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeIrattribution(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Irattribution = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readLosstype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Losstype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Losstype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeLosstype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Losstype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readNetrate(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Netrate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Netrate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeNetrate(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Netrate = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readRateunit(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Rateunit == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Rateunit)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeRateunit(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Rateunit = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readThetaattribution(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Thetaattribution == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Thetaattribution)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeThetaattribution(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Thetaattribution = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readVegaattribution(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Vegaattribution == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Vegaattribution)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeVegaattribution(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Vegaattribution = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readArchive(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Archive == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Archive)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeArchive(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Archive = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readDeltaexposure(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Deltaexposure == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Deltaexposure)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeDeltaexposure(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Deltaexposure = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readDeltanpvfactor(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Deltanpvfactor == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Deltanpvfactor)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeDeltanpvfactor(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Deltanpvfactor = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTimeunit(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Timeunit == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Timeunit)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTimeunit(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Timeunit = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readDuration(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Duration == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Duration)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeDuration(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Duration = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExpcurrency(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Expcurrency == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Expcurrency)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExpcurrency(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Expcurrency = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExpprice(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Expprice == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Expprice)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExpprice(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Expprice = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExppriceunit(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Exppriceunit == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Exppriceunit)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExppriceunit(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Exppriceunit = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPriceexpquantity(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Priceexpquantity == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Priceexpquantity)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePriceexpquantity(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Priceexpquantity = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readRecordtype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Recordtype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Recordtype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeRecordtype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Recordtype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPositiontype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Positiontype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Positiontype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePositiontype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Positiontype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_destinationtradebook(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_destinationtradebook == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_destinationtradebook)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_destinationtradebook(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_destinationtradebook = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_internalposition(x ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8) {
	switch {
	case x.Jeragm_internalposition == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_internalposition)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_internalposition(x *ValuationDetail, vals []bool, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_internalposition = pbool(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readVessel(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Vessel == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Vessel)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeVessel(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Vessel = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_cargospecification(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_cargospecification == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_cargospecification)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_cargospecification(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_cargospecification = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_cargostatus(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_cargostatus == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_cargostatus)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_cargostatus(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_cargostatus = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_flexcategory(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_flexcategory == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_flexcategory)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_flexcategory(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_flexcategory = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_jeraltcname(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_jeraltcname == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_jeraltcname)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_jeraltcname(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_jeraltcname = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTradestrategy(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Tradestrategy == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Tradestrategy)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTradestrategy(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Tradestrategy = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_buysell(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_buysell == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_buysell)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_buysell(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_buysell = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_cash(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_cash == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_cash)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_cash(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_cash = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_cashexp(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_cashexp == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_cashexp)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_cashexp(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_cashexp = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_cashvalue(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_cashvalue == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_cashvalue)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_cashvalue(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_cashvalue = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_disccash(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_disccash == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_disccash)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_disccash(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_disccash = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_discountedcashvalue(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_discountedcashvalue == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_discountedcashvalue)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_discountedcashvalue(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_discountedcashvalue = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_exposure(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_exposure == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_exposure)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_exposure(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_exposure = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_fxstate(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_fxstate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_fxstate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_fxstate(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_fxstate = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_pricemarketprice(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_pricemarketprice == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_pricemarketprice)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_pricemarketprice(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_pricemarketprice = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_pricestate(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_pricestate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_pricestate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_pricestate(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_pricestate = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_product(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_product == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_product)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_product(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_product = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_qtyunit(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_qtyunit == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_qtyunit)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_qtyunit(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_qtyunit = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_quant(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_quant == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_quant)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_quant(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_quant = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_rate(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_rate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_rate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_rate(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_rate = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readRate(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Rate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Rate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeRate(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Rate = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readSwaptype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Swaptype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Swaptype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeSwaptype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Swaptype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExpproduct(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Expproduct == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Expproduct)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExpproduct(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Expproduct = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExpproducttype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Expproducttype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Expproducttype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExpproducttype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Expproducttype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExpreportingqty(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Expreportingqty == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Expreportingqty)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExpreportingqty(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Expreportingqty = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExpreportingunit(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Expreportingunit == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Expreportingunit)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExpreportingunit(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Expreportingunit = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readMarketareapi(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Marketareapi == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Marketareapi)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeMarketareapi(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Marketareapi = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_freightshipment(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_freightshipment == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_freightshipment)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_freightshipment(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_freightshipment = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExchange(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Exchange == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Exchange)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExchange(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Exchange = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_postingtype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_postingtype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_postingtype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_postingtype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_postingtype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readPositionmode(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Positionmode == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Positionmode)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writePositionmode(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Positionmode = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_fullypriced(x ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8) {
	switch {
	case x.Jeragm_fullypriced == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_fullypriced)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_fullypriced(x *ValuationDetail, vals []bool, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_fullypriced = pbool(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_marktoIntentprice(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_marktoIntentprice == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_marktoIntentprice)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_marktoIntentprice(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_marktoIntentprice = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_marktointentvalue(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_marktointentvalue == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_marktointentvalue)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_marktointentvalue(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_marktointentvalue = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_intransitinventory(x ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8) {
	switch {
	case x.Jeragm_intransitinventory == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_intransitinventory)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_intransitinventory(x *ValuationDetail, vals []bool, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_intransitinventory = pbool(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_PosEndDateInFuture(x ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8) {
	switch {
	case x.Jeragm_PosEndDateInFuture == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_PosEndDateInFuture)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_PosEndDateInFuture(x *ValuationDetail, vals []bool, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_PosEndDateInFuture = pbool(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_settlementstatus(x ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8) {
	switch {
	case x.Jeragm_settlementstatus == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_settlementstatus)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_settlementstatus(x *ValuationDetail, vals []bool, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_settlementstatus = pbool(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_fullypricedpos(x ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8) {
	switch {
	case x.Jeragm_fullypricedpos == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_fullypricedpos)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_fullypricedpos(x *ValuationDetail, vals []bool, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_fullypricedpos = pbool(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_duedate(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Jeragm_duedate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_duedate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_duedate(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_duedate = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readContainer(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Container == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Container)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeContainer(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Container = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readContainertype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Containertype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Containertype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeContainertype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Containertype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExchangematchid(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Exchangematchid == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Exchangematchid)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExchangematchid(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Exchangematchid = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readLossquantity(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Lossquantity == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Lossquantity)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeLossquantity(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Lossquantity = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readUnitseq(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Unitseq == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Unitseq)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeUnitseq(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Unitseq = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExpreportingqty2(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Expreportingqty2 == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Expreportingqty2)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExpreportingqty2(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Expreportingqty2 = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExpreportingqty3(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Expreportingqty3 == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Expreportingqty3)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExpreportingqty3(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Expreportingqty3 = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExpreportingunit2(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Expreportingunit2 == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Expreportingunit2)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExpreportingunit2(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Expreportingunit2 = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readExpreportingunit3(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Expreportingunit3 == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Expreportingunit3)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeExpreportingunit3(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Expreportingunit3 = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readTl_sourcetrade(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Tl_sourcetrade == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Tl_sourcetrade)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeTl_sourcetrade(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Tl_sourcetrade = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_brand(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_brand == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_brand)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_brand(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_brand = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_includeincvbaseprice(x ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8) {
	switch {
	case x.Jeragm_includeincvbaseprice == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_includeincvbaseprice)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_includeincvbaseprice(x *ValuationDetail, vals []bool, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_includeincvbaseprice = pbool(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_referencecv(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_referencecv == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_referencecv)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_referencecv(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_referencecv = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readIncoterms(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Incoterms == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Incoterms)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeIncoterms(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Incoterms = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_final(x ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8) {
	switch {
	case x.Jeragm_final == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_final)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_final(x *ValuationDetail, vals []bool, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_final = pbool(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_bestavailablecv(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_bestavailablecv == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_bestavailablecv)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_bestavailablecv(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_bestavailablecv = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_marktointentaccrualvalue(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_marktointentaccrualvalue == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_marktointentaccrualvalue)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_marktointentaccrualvalue(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_marktointentaccrualvalue = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_fxconversion(x ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8) {
	switch {
	case x.Jeragm_fxconversion == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_fxconversion)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_fxconversion(x *ValuationDetail, vals []bool, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_fxconversion = pbool(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_fxcurrencybegtime(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Jeragm_fxcurrencybegtime == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_fxcurrencybegtime)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_fxcurrencybegtime(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_fxcurrencybegtime = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_fxcurrencyendtime(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Jeragm_fxcurrencyendtime == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_fxcurrencyendtime)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_fxcurrencyendtime(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_fxcurrencyendtime = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_bldate(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Jeragm_bldate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_bldate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_bldate(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_bldate = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_matchno(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_matchno == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_matchno)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_matchno(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_matchno = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readBunkertype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Bunkertype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Bunkertype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeBunkertype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Bunkertype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readGammacurve(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Gammacurve == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Gammacurve)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeGammacurve(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Gammacurve = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readHedgecurve(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Hedgecurve == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Hedgecurve)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeHedgecurve(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Hedgecurve = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readVegacurve(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Vegacurve == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Vegacurve)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeVegacurve(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Vegacurve = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_fxrate(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_fxrate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_fxrate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_fxrate(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_fxrate = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_originaldelta(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_originaldelta == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_originaldelta)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_originaldelta(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_originaldelta = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_yearquarter(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_yearquarter == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_yearquarter)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_yearquarter(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_yearquarter = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_deliverymonth(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Jeragm_deliverymonth == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_deliverymonth)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_deliverymonth(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_deliverymonth = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_deliveryquarter(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Jeragm_deliveryquarter == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_deliveryquarter)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_deliveryquarter(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_deliveryquarter = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_deliveryyear(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Jeragm_deliveryyear == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_deliveryyear)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_deliveryyear(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_deliveryyear = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_deltaposition(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_deltaposition == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_deltaposition)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_deltaposition(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_deltaposition = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_discexp(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_discexp == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_discexp)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_discexp(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_discexp = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_discexp2(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_discexp2 == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_discexp2)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_discexp2(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_discexp2 = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_discexp3(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_discexp3 == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_discexp3)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_discexp3(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_discexp3 = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_expmonth(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_expmonth == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_expmonth)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_expmonth(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_expmonth = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_expmonth_coal(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_expmonth_coal == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_expmonth_coal)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_expmonth_coal(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_expmonth_coal = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_expseasons(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_expseasons == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_expseasons)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_expseasons(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_expseasons = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_expyears(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_expyears == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_expyears)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_expyears(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_expyears = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_expquarters(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_expquarters == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_expquarters)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_expquarters(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_expquarters = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_quality_(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_quality_ == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_quality_)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_quality_(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_quality_ = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_reppostype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_reppostype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_reppostype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_reppostype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_reppostype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_exposurestatus(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_exposurestatus == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_exposurestatus)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_exposurestatus(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_exposurestatus = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_exprolloffdate(x ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8) {
	switch {
	case x.Jeragm_exprolloffdate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_exprolloffdate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_exprolloffdate(x *ValuationDetail, vals []int64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_exprolloffdate = pint64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_signedpriceqty(x ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8) {
	switch {
	case x.Jeragm_signedpriceqty == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_signedpriceqty)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_signedpriceqty(x *ValuationDetail, vals []float64, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_signedpriceqty = pfloat64(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readRangepricingtype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Rangepricingtype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Rangepricingtype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeRangepricingtype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Rangepricingtype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_customdisaggkey(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_customdisaggkey == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_customdisaggkey)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_customdisaggkey(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_customdisaggkey = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_customdisagglabel(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_customdisagglabel == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_customdisagglabel)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_customdisagglabel(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_customdisagglabel = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_concatenation(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_concatenation == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_concatenation)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_concatenation(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_concatenation = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_customposref(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_customposref == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_customposref)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_customposref(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_customposref = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_customtraderef(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_customtraderef == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_customtraderef)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_customtraderef(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_customtraderef = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_getraderef(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_getraderef == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_getraderef)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_getraderef(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_getraderef = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_priceindex(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_priceindex == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_priceindex)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_priceindex(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_priceindex = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readIntrinsicprice(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Intrinsicprice == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Intrinsicprice)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeIntrinsicprice(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Intrinsicprice = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_mmvolannual(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_mmvolannual == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_mmvolannual)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_mmvolannual(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_mmvolannual = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_mmvoltomaturity(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_mmvoltomaturity == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_mmvoltomaturity)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_mmvoltomaturity(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_mmvoltomaturity = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_nfixings(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_nfixings == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_nfixings)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_nfixings(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_nfixings = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_settlementprice(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_settlementprice == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_settlementprice)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_settlementprice(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_settlementprice = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_settlementtype(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_settlementtype == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_settlementtype)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_settlementtype(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_settlementtype = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_cashnpvfactororiginal(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_cashnpvfactororiginal == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_cashnpvfactororiginal)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_cashnpvfactororiginal(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_cashnpvfactororiginal = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_cashnpvfactorusd(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_cashnpvfactorusd == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_cashnpvfactorusd)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_cashnpvfactorusd(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_cashnpvfactorusd = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_currexchratecashusd(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_currexchratecashusd == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_currexchratecashusd)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_currexchratecashusd(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_currexchratecashusd = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_currexchratespot(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_currexchratespot == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_currexchratespot)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_currexchratespot(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_currexchratespot = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_currexchratespotusd(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_currexchratespotusd == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_currexchratespotusd)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_currexchratespotusd(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_currexchratespotusd = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_timetoexpiry(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_timetoexpiry == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_timetoexpiry)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_timetoexpiry(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_timetoexpiry = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func readJeragm_fxdiscountdate(x ValuationDetail, vals []string, defs, reps []uint8) ([]string, []uint8, []uint8) {
	switch {
	case x.Jeragm_fxdiscountdate == nil:
		defs = append(defs, 0)
		return vals, defs, reps
	default:
		vals = append(vals, *x.Jeragm_fxdiscountdate)
		defs = append(defs, 1)
		return vals, defs, reps
	}
}

func writeJeragm_fxdiscountdate(x *ValuationDetail, vals []string, defs, reps []uint8) (int, int) {
	def := defs[0]
	switch def {
	case 1:
		x.Jeragm_fxdiscountdate = pstring(vals[0])
		return 1, 1
	}

	return 0, 1
}

func fieldCompression(c compression) func(*parquet.RequiredField) {
	switch c {
	case compressionUncompressed:
		return parquet.RequiredFieldUncompressed
	case compressionSnappy:
		return parquet.RequiredFieldSnappy
	case compressionGzip:
		return parquet.RequiredFieldGzip
	default:
		return parquet.RequiredFieldUncompressed
	}
}

func optionalFieldCompression(c compression) func(*parquet.OptionalField) {
	switch c {
	case compressionUncompressed:
		return parquet.OptionalFieldUncompressed
	case compressionSnappy:
		return parquet.OptionalFieldSnappy
	case compressionGzip:
		return parquet.OptionalFieldGzip
	default:
		return parquet.OptionalFieldUncompressed
	}
}

func NewParquetWriter(w io.Writer, opts ...func(*ParquetWriter) error) (*ParquetWriter, error) {
	return newParquetWriter(w, append(opts, begin)...)
}

func newParquetWriter(w io.Writer, opts ...func(*ParquetWriter) error) (*ParquetWriter, error) {
	p := &ParquetWriter{
		max:         1000,
		w:           w,
		compression: compressionSnappy,
	}

	for _, opt := range opts {
		if err := opt(p); err != nil {
			return nil, err
		}
	}

	p.fields = Fields(p.compression)
	if p.meta == nil {
		ff := Fields(p.compression)
		schema := make([]parquet.Field, len(ff))
		for i, f := range ff {
			schema[i] = f.Schema()
		}
		p.meta = parquet.New(schema...)
	}

	return p, nil
}

// MaxPageSize is the maximum number of rows in each row groups' page.
func MaxPageSize(m int) func(*ParquetWriter) error {
	return func(p *ParquetWriter) error {
		p.max = m
		return nil
	}
}

var par1 = []byte("PAR1")

func begin(p *ParquetWriter) error {
	_, err := p.w.Write(par1)
	return err
}

func withMeta(m *parquet.Metadata) func(*ParquetWriter) error {
	return func(p *ParquetWriter) error {
		p.meta = m
		return nil
	}
}

func Uncompressed(p *ParquetWriter) error {
	p.compression = compressionUncompressed
	return nil
}

func Snappy(p *ParquetWriter) error {
	p.compression = compressionSnappy
	return nil
}

func Gzip(p *ParquetWriter) error {
	p.compression = compressionGzip
	return nil
}

func withCompression(c compression) func(*ParquetWriter) error {
	return func(p *ParquetWriter) error {
		p.compression = c
		return nil
	}
}

func (p *ParquetWriter) Write() error {
	for i, f := range p.fields {
		if err := f.Write(p.w, p.meta); err != nil {
			return err
		}

		for child := p.child; child != nil; child = child.child {
			if err := child.fields[i].Write(p.w, p.meta); err != nil {
				return err
			}
		}
	}

	p.fields = Fields(p.compression)
	p.child = nil
	p.len = 0

	schema := make([]parquet.Field, len(p.fields))
	for i, f := range p.fields {
		schema[i] = f.Schema()
	}
	p.meta.StartRowGroup(schema...)
	return nil
}

func (p *ParquetWriter) Close() error {
	if err := p.meta.Footer(p.w); err != nil {
		return err
	}

	_, err := p.w.Write(par1)
	return err
}

func (p *ParquetWriter) Add(rec ValuationDetail) {
	if p.len == p.max {
		if p.child == nil {
			// an error can't happen here
			p.child, _ = newParquetWriter(p.w, MaxPageSize(p.max), withMeta(p.meta), withCompression(p.compression))
		}

		p.child.Add(rec)
		return
	}

	p.meta.NextDoc()
	for _, f := range p.fields {
		f.Add(rec)
	}

	p.len++
}

type Field interface {
	Add(r ValuationDetail)
	Write(w io.Writer, meta *parquet.Metadata) error
	Schema() parquet.Field
	Scan(r *ValuationDetail)
	Read(r io.ReadSeeker, pg parquet.Page) error
	Name() string
	Levels() ([]uint8, []uint8)
}

func getFields(ff []Field) map[string]Field {
	m := make(map[string]Field, len(ff))
	for _, f := range ff {
		m[f.Name()] = f
	}
	return m
}

func NewParquetReader(r io.ReadSeeker, opts ...func(*ParquetReader)) (*ParquetReader, error) {
	ff := Fields(compressionUnknown)
	pr := &ParquetReader{
		r: r,
	}

	for _, opt := range opts {
		opt(pr)
	}

	schema := make([]parquet.Field, len(ff))
	for i, f := range ff {
		pr.fieldNames = append(pr.fieldNames, f.Name())
		schema[i] = f.Schema()
	}

	meta := parquet.New(schema...)
	if err := meta.ReadFooter(r); err != nil {
		return nil, err
	}
	pr.rows = meta.Rows()
	var err error
	pr.pages, err = meta.Pages()
	if err != nil {
		return nil, err
	}

	pr.rowGroups = meta.RowGroups()
	_, err = r.Seek(4, io.SeekStart)
	if err != nil {
		return nil, err
	}
	pr.meta = meta

	return pr, pr.readRowGroup()
}

func readerIndex(i int) func(*ParquetReader) {
	return func(p *ParquetReader) {
		p.index = i
	}
}

// ParquetReader reads one page from a row group.
type ParquetReader struct {
	fields         map[string]Field
	fieldNames     []string
	index          int
	cursor         int64
	rows           int64
	rowGroupCursor int64
	rowGroupCount  int64
	pages          map[string][]parquet.Page
	meta           *parquet.Metadata
	err            error

	r         io.ReadSeeker
	rowGroups []parquet.RowGroup
}

type Levels struct {
	Name string
	Defs []uint8
	Reps []uint8
}

func (p *ParquetReader) Levels() []Levels {
	var out []Levels
	//for {
	for _, name := range p.fieldNames {
		f := p.fields[name]
		d, r := f.Levels()
		out = append(out, Levels{Name: f.Name(), Defs: d, Reps: r})
	}
	//	if err := p.readRowGroup(); err != nil {
	//		break
	//	}
	//}
	return out
}

func (p *ParquetReader) Error() error {
	return p.err
}

func (p *ParquetReader) readRowGroup() error {
	p.rowGroupCursor = 0

	if len(p.rowGroups) == 0 {
		p.rowGroupCount = 0
		return nil
	}

	rg := p.rowGroups[0]
	p.fields = getFields(Fields(compressionUnknown))
	p.rowGroupCount = rg.Rows
	p.rowGroupCursor = 0
	for _, col := range rg.Columns() {
		name := strings.Join(col.MetaData.PathInSchema, ".")
		f, ok := p.fields[name]
		if !ok {
			return fmt.Errorf("unknown field: %s", name)
		}
		pages := p.pages[name]
		if len(pages) <= p.index {
			break
		}

		pg := pages[0]
		if err := f.Read(p.r, pg); err != nil {
			return fmt.Errorf("unable to read field %s, err: %s", f.Name(), err)
		}
		p.pages[name] = p.pages[name][1:]
	}
	p.rowGroups = p.rowGroups[1:]
	return nil
}

func (p *ParquetReader) Rows() int64 {
	return p.rows
}

func (p *ParquetReader) Next() bool {
	if p.err == nil && p.cursor >= p.rows {
		return false
	}
	if p.rowGroupCursor >= p.rowGroupCount {
		p.err = p.readRowGroup()
		if p.err != nil {
			return false
		}
	}

	p.cursor++
	p.rowGroupCursor++
	return true
}

func (p *ParquetReader) Scan(x *ValuationDetail) {
	if p.err != nil {
		return
	}

	for _, name := range p.fieldNames {
		f := p.fields[name]
		f.Scan(x)
	}
}

type Float64OptionalField struct {
	parquet.OptionalField
	vals  []float64
	read  func(r ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8)
	write func(r *ValuationDetail, vals []float64, defs, reps []uint8) (int, int)
	stats *float64optionalStats
}

func NewFloat64OptionalField(read func(r ValuationDetail, vals []float64, defs, reps []uint8) ([]float64, []uint8, []uint8), write func(r *ValuationDetail, vals []float64, defs, reps []uint8) (int, int), path []string, types []int, opts ...func(*parquet.OptionalField)) *Float64OptionalField {
	return &Float64OptionalField{
		read:          read,
		write:         write,
		OptionalField: parquet.NewOptionalField(path, types, opts...),
		stats:         newfloat64optionalStats(maxDef(types)),
	}
}

func (f *Float64OptionalField) Schema() parquet.Field {
	return parquet.Field{Name: f.Name(), Path: f.Path(), Type: Float64Type, RepetitionType: f.RepetitionType, Types: f.Types}
}

func (f *Float64OptionalField) Write(w io.Writer, meta *parquet.Metadata) error {
	buf := buffpool.Get()
	defer buffpool.Put(buf)

	bs := make([]byte, 8)
	for _, v := range f.vals {
		binary.LittleEndian.PutUint64(bs, math.Float64bits(v))
		if _, err := buf.Write(bs); err != nil {
			return err
		}
	}
	return f.DoWrite(w, meta, buf.Bytes(), len(f.Defs), f.stats)
}

func (f *Float64OptionalField) Read(r io.ReadSeeker, pg parquet.Page) error {
	rr, _, err := f.DoRead(r, pg)
	if err != nil {
		return err
	}

	v := make([]float64, f.Values()-len(f.vals))
	err = binary.Read(rr, binary.LittleEndian, &v)
	f.vals = append(f.vals, v...)
	return err
}

func (f *Float64OptionalField) Add(r ValuationDetail) {
	vals, defs, reps := f.read(r, f.vals, f.Defs, f.Reps)
	f.stats.add(vals[len(f.vals):], defs[len(f.Defs):])
	f.vals = vals
	f.Defs = defs
	f.Reps = reps
}

func (f *Float64OptionalField) Scan(r *ValuationDetail) {
	if len(f.Defs) == 0 {
		return
	}

	v, l := f.write(r, f.vals, f.Defs, f.Reps)
	f.vals = f.vals[v:]
	f.Defs = f.Defs[l:]
	if len(f.Reps) > 0 {
		f.Reps = f.Reps[l:]
	}
}

func (f *Float64OptionalField) Levels() ([]uint8, []uint8) {
	return f.Defs, f.Reps
}

type StringOptionalField struct {
	parquet.OptionalField
	vals  []string
	read  func(r ValuationDetail, vals []string, def, rep []uint8) ([]string, []uint8, []uint8)
	write func(r *ValuationDetail, vals []string, def, rep []uint8) (int, int)
	stats *stringOptionalStats
}

func NewStringOptionalField(read func(r ValuationDetail, vals []string, def, rep []uint8) ([]string, []uint8, []uint8), write func(r *ValuationDetail, vals []string, defs, reps []uint8) (int, int), path []string, types []int, opts ...func(*parquet.OptionalField)) *StringOptionalField {
	return &StringOptionalField{
		read:          read,
		write:         write,
		OptionalField: parquet.NewOptionalField(path, types, opts...),
		stats:         newStringOptionalStats(maxDef(types)),
	}
}

func (f *StringOptionalField) Schema() parquet.Field {
	return parquet.Field{Name: f.Name(), Path: f.Path(), Type: StringType, RepetitionType: f.RepetitionType, Types: f.Types}
}

func (f *StringOptionalField) Add(r ValuationDetail) {
	vals, defs, reps := f.read(r, f.vals, f.Defs, f.Reps)
	f.stats.add(vals[len(f.vals):], defs[len(f.Defs):])
	f.vals = vals
	f.Defs = defs
	f.Reps = reps
}

func (f *StringOptionalField) Scan(r *ValuationDetail) {
	if len(f.Defs) == 0 {
		return
	}

	v, l := f.write(r, f.vals, f.Defs, f.Reps)
	f.vals = f.vals[v:]
	f.Defs = f.Defs[l:]
	if len(f.Reps) > 0 {
		f.Reps = f.Reps[l:]
	}
}

func (f *StringOptionalField) Write(w io.Writer, meta *parquet.Metadata) error {
	buf := buffpool.Get()
	defer buffpool.Put(buf)

	bs := make([]byte, 4)
	for _, s := range f.vals {
		binary.LittleEndian.PutUint32(bs, uint32(len(s)))
		if _, err := buf.Write(bs); err != nil {
			return err
		}
		buf.WriteString(s)
	}

	return f.DoWrite(w, meta, buf.Bytes(), len(f.Defs), f.stats)
}

func (f *StringOptionalField) Read(r io.ReadSeeker, pg parquet.Page) error {
	rr, _, err := f.DoRead(r, pg)
	if err != nil {
		return err
	}

	for j := 0; j < f.Values(); j++ {
		var x int32
		if err := binary.Read(rr, binary.LittleEndian, &x); err != nil {
			return err
		}
		s := make([]byte, x)
		if _, err := rr.Read(s); err != nil {
			return err
		}

		f.vals = append(f.vals, string(s))
	}
	return nil
}

func (f *StringOptionalField) Levels() ([]uint8, []uint8) {
	return f.Defs, f.Reps
}

type Int64OptionalField struct {
	parquet.OptionalField
	vals  []int64
	read  func(r ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8)
	write func(r *ValuationDetail, vals []int64, defs, reps []uint8) (int, int)
	stats *int64optionalStats
}

func NewInt64OptionalField(read func(r ValuationDetail, vals []int64, defs, reps []uint8) ([]int64, []uint8, []uint8), write func(r *ValuationDetail, vals []int64, defs, reps []uint8) (int, int), path []string, types []int, opts ...func(*parquet.OptionalField)) *Int64OptionalField {
	return &Int64OptionalField{
		read:          read,
		write:         write,
		OptionalField: parquet.NewOptionalField(path, types, opts...),
		stats:         newint64optionalStats(maxDef(types)),
	}
}

func (f *Int64OptionalField) Schema() parquet.Field {
	return parquet.Field{Name: f.Name(), Path: f.Path(), Type: Int64Type, RepetitionType: f.RepetitionType, Types: f.Types}
}

func (f *Int64OptionalField) Write(w io.Writer, meta *parquet.Metadata) error {
	buf := buffpool.Get()
	defer buffpool.Put(buf)

	bs := make([]byte, 8)
	for _, v := range f.vals {
		binary.LittleEndian.PutUint64(bs, uint64(v))
		if _, err := buf.Write(bs); err != nil {
			return err
		}
	}
	return f.DoWrite(w, meta, buf.Bytes(), len(f.Defs), f.stats)
}

func (f *Int64OptionalField) Read(r io.ReadSeeker, pg parquet.Page) error {
	rr, _, err := f.DoRead(r, pg)
	if err != nil {
		return err
	}

	v := make([]int64, f.Values()-len(f.vals))
	err = binary.Read(rr, binary.LittleEndian, &v)
	f.vals = append(f.vals, v...)
	return err
}

func (f *Int64OptionalField) Add(r ValuationDetail) {
	vals, defs, reps := f.read(r, f.vals, f.Defs, f.Reps)
	f.stats.add(vals[len(f.vals):], defs[len(f.Defs):])
	f.vals = vals
	f.Defs = defs
	f.Reps = reps
}

func (f *Int64OptionalField) Scan(r *ValuationDetail) {
	if len(f.Defs) == 0 {
		return
	}

	v, l := f.write(r, f.vals, f.Defs, f.Reps)
	f.vals = f.vals[v:]
	f.Defs = f.Defs[l:]
	if len(f.Reps) > 0 {
		f.Reps = f.Reps[l:]
	}
}

func (f *Int64OptionalField) Levels() ([]uint8, []uint8) {
	return f.Defs, f.Reps
}

type BoolOptionalField struct {
	parquet.OptionalField
	vals  []bool
	read  func(r ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8)
	write func(r *ValuationDetail, vals []bool, defs, reps []uint8) (int, int)
	stats *boolOptionalStats
}

func NewBoolOptionalField(read func(r ValuationDetail, vals []bool, defs, reps []uint8) ([]bool, []uint8, []uint8), write func(r *ValuationDetail, vals []bool, defs, reps []uint8) (int, int), path []string, types []int, opts ...func(*parquet.OptionalField)) *BoolOptionalField {
	return &BoolOptionalField{
		read:          read,
		write:         write,
		OptionalField: parquet.NewOptionalField(path, types, opts...),
		stats:         newBoolOptionalStats(maxDef(types)),
	}
}

func (f *BoolOptionalField) Schema() parquet.Field {
	return parquet.Field{Name: f.Name(), Path: f.Path(), Type: BoolType, RepetitionType: f.RepetitionType, Types: f.Types}
}

func (f *BoolOptionalField) Read(r io.ReadSeeker, pg parquet.Page) error {
	rr, sizes, err := f.DoRead(r, pg)
	if err != nil {
		return err
	}

	v, err := parquet.GetBools(rr, f.Values()-len(f.vals), sizes)
	f.vals = append(f.vals, v...)
	return err
}

func (f *BoolOptionalField) Scan(r *ValuationDetail) {
	if len(f.Defs) == 0 {
		return
	}

	v, l := f.write(r, f.vals, f.Defs, f.Reps)
	f.vals = f.vals[v:]
	f.Defs = f.Defs[l:]
	if len(f.Reps) > 0 {
		f.Reps = f.Reps[l:]
	}
}

func (f *BoolOptionalField) Add(r ValuationDetail) {
	vals, defs, reps := f.read(r, f.vals, f.Defs, f.Reps)
	f.stats.add(vals[len(f.vals):], defs[len(f.Defs):])
	f.vals = vals
	f.Defs = defs
	f.Reps = reps
}

func (f *BoolOptionalField) Write(w io.Writer, meta *parquet.Metadata) error {
	ln := len(f.vals)
	byteNum := (ln + 7) / 8
	rawBuf := make([]byte, byteNum)

	for i := 0; i < ln; i++ {
		if f.vals[i] {
			rawBuf[i/8] = rawBuf[i/8] | (1 << uint32(i%8))
		}
	}

	return f.DoWrite(w, meta, rawBuf, len(f.Defs), f.stats)
}

func (f *BoolOptionalField) Levels() ([]uint8, []uint8) {
	return f.Defs, f.Reps
}

type float64optionalStats struct {
	min     float64
	max     float64
	nils    int64
	nonNils int64
	maxDef  uint8
}

func newfloat64optionalStats(d uint8) *float64optionalStats {
	return &float64optionalStats{
		min:    float64(math.MaxFloat64),
		maxDef: d,
	}
}

func (f *float64optionalStats) add(vals []float64, defs []uint8) {
	var i int
	for _, def := range defs {
		if def < f.maxDef {
			f.nils++
		} else {
			val := vals[i]
			i++

			f.nonNils++
			if val < f.min {
				f.min = val
			}
			if val > f.max {
				f.max = val
			}
		}
	}
}

func (f *float64optionalStats) bytes(v float64) []byte {
	bs := make([]byte, 8)
	binary.LittleEndian.PutUint64(bs, math.Float64bits(v))
	return bs
}

func (f *float64optionalStats) NullCount() *int64 {
	return &f.nils
}

func (f *float64optionalStats) DistinctCount() *int64 {
	return nil
}

func (f *float64optionalStats) Min() []byte {
	if f.nonNils == 0 {
		return nil
	}
	return f.bytes(f.min)
}

func (f *float64optionalStats) Max() []byte {
	if f.nonNils == 0 {
		return nil
	}
	return f.bytes(f.max)
}

const nilOptString = "__#NIL#__"

type stringOptionalStats struct {
	min    string
	max    string
	nils   int64
	maxDef uint8
}

func newStringOptionalStats(d uint8) *stringOptionalStats {
	return &stringOptionalStats{
		min:    nilOptString,
		max:    nilOptString,
		maxDef: d,
	}
}

func (s *stringOptionalStats) add(vals []string, defs []uint8) {
	var i int
	for _, def := range defs {
		if def < s.maxDef {
			s.nils++
		} else {
			val := vals[i]
			if s.min == nilOptString {
				s.min = val
			} else {
				if val < s.min {
					s.min = val
				}
			}
			if s.max == nilOptString {
				s.max = val
			} else {
				if val > s.max {
					s.max = val
				}
			}
			i++
		}
	}
}

func (s *stringOptionalStats) NullCount() *int64 {
	return &s.nils
}

func (s *stringOptionalStats) DistinctCount() *int64 {
	return nil
}

func (s *stringOptionalStats) Min() []byte {
	if s.min == nilOptString {
		return nil
	}
	return []byte(s.min)
}

func (s *stringOptionalStats) Max() []byte {
	if s.max == nilOptString {
		return nil
	}
	return []byte(s.max)
}

type int64optionalStats struct {
	min     int64
	max     int64
	nils    int64
	nonNils int64
	maxDef  uint8
}

func newint64optionalStats(d uint8) *int64optionalStats {
	return &int64optionalStats{
		min:    int64(math.MaxInt64),
		maxDef: d,
	}
}

func (f *int64optionalStats) add(vals []int64, defs []uint8) {
	var i int
	for _, def := range defs {
		if def < f.maxDef {
			f.nils++
		} else {
			val := vals[i]
			i++

			f.nonNils++
			if val < f.min {
				f.min = val
			}
			if val > f.max {
				f.max = val
			}
		}
	}
}

func (f *int64optionalStats) bytes(v int64) []byte {
	bs := make([]byte, 8)
	binary.LittleEndian.PutUint64(bs, uint64(v))
	return bs
}

func (f *int64optionalStats) NullCount() *int64 {
	return &f.nils
}

func (f *int64optionalStats) DistinctCount() *int64 {
	return nil
}

func (f *int64optionalStats) Min() []byte {
	if f.nonNils == 0 {
		return nil
	}
	return f.bytes(f.min)
}

func (f *int64optionalStats) Max() []byte {
	if f.nonNils == 0 {
		return nil
	}
	return f.bytes(f.max)
}

type boolOptionalStats struct {
	maxDef uint8
	nils   int64
}

func newBoolOptionalStats(d uint8) *boolOptionalStats {
	return &boolOptionalStats{maxDef: d}
}

func (b *boolOptionalStats) add(vals []bool, defs []uint8) {
	for _, def := range defs {
		if def < b.maxDef {
			b.nils++
		}
	}
}

func (b *boolOptionalStats) NullCount() *int64 {
	return &b.nils
}

func (b *boolOptionalStats) DistinctCount() *int64 {
	return nil
}

func (b *boolOptionalStats) Min() []byte {
	return nil
}

func (b *boolOptionalStats) Max() []byte {
	return nil
}

func pint32(i int32) *int32       { return &i }
func puint32(i uint32) *uint32    { return &i }
func pint64(i int64) *int64       { return &i }
func puint64(i uint64) *uint64    { return &i }
func pbool(b bool) *bool          { return &b }
func pstring(s string) *string    { return &s }
func pfloat32(f float32) *float32 { return &f }
func pfloat64(f float64) *float64 { return &f }

// keeps track of the indices of repeated fields
// that have already been handled by a previous field
type indices []int

func (i indices) rep(rep uint8) {
	if rep > 0 {
		r := int(rep) - 1
		i[r] = i[r] + 1
		for j := int(rep); j < len(i); j++ {
			i[j] = 0
		}
	}
}

func maxDef(types []int) uint8 {
	var out uint8
	for _, typ := range types {
		if typ > 0 {
			out++
		}
	}
	return out
}

func Int32Type(se *sch.SchemaElement) {
	t := sch.Type_INT32
	se.Type = &t
}

func Uint32Type(se *sch.SchemaElement) {
	t := sch.Type_INT32
	se.Type = &t
	ct := sch.ConvertedType_UINT_32
	se.ConvertedType = &ct
}

func Int64Type(se *sch.SchemaElement) {
	t := sch.Type_INT64
	se.Type = &t
}

func Uint64Type(se *sch.SchemaElement) {
	t := sch.Type_INT64
	se.Type = &t
	ct := sch.ConvertedType_UINT_64
	se.ConvertedType = &ct
}

func Float32Type(se *sch.SchemaElement) {
	t := sch.Type_FLOAT
	se.Type = &t
}

func Float64Type(se *sch.SchemaElement) {
	t := sch.Type_DOUBLE
	se.Type = &t
}

func BoolType(se *sch.SchemaElement) {
	t := sch.Type_BOOLEAN
	se.Type = &t
}

func StringType(se *sch.SchemaElement) {
	t := sch.Type_BYTE_ARRAY
	se.Type = &t
}
